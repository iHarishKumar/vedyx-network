// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {IReactive} from "reactive-lib/interfaces/IReactive.sol";
import {AbstractPausableReactive} from "reactive-lib/abstract-base/AbstractPausableReactive.sol";
import {ISystemContract} from "reactive-lib/interfaces/ISystemContract.sol";
import {IAttackVectorDetector} from "./IAttackVectorDetector.sol";

// ─── Custom Errors ────────────────────────────────────────────────────
error InvalidTokenAddress();
error ThresholdMustBeGreaterThanZero();
error ArrayLengthMismatch();
error TokenNotConfigured();
error DetectorAlreadyRegistered();
error DetectorNotFound();
error InvalidDetectorAddress();

/**
 * @title VedyxExploitDetectorRSC
 * @notice Singleton Reactive Smart Contract deployed on Reactive Network.
 *         Uses a modular registry pattern to support pluggable attack vector detectors.
 *         Subscribes to high-risk event signatures across multiple EVM chains,
 *         analyses each incoming log using registered detectors, and — when a
 *         match is found — emits a Callback that tags the originator address
 *         as suspicious on a designated destination-chain registry.
*
 * ─── Singleton Pattern ───────────────────────────────────────────────────────
 *   This contract acts as a central hub for all exploit detection logic.
 *   New attack vectors can be added by:
 *   1. Implementing the IAttackVectorDetector interface
 *   2. Registering the detector using registerDetector()
 *   3. The detector will automatically be invoked for matching events
 *
 * ─── How it works ────────────────────────────────────────────────────────────
 *   1. Owner registers attack vector detectors that implement IAttackVectorDetector
 *   2. Detectors are mapped by their monitored topic_0 for efficient lookup
 *   3. The ReactVM runtime calls `react()` for every matching log
 *   4. `react()` delegates to the appropriate detector based on topic_0
 *   5. If a threat is detected, the detector returns the payload to send
 *   6. The contract emits a Callback to the destination chain registry
 */
contract VedyxExploitDetectorRSC is AbstractPausableReactive {
    // ─── System / plumbing ────────────────────────────────────────────────
    address private callbackContract; // destination-chain registry address
    uint256 private destinationChainId;
    mapping(bytes32 => bool) private subscriptionStatus;
    mapping(bytes32 => Subscription) private subscriptionsByKey;
    mapping(bytes32 => bool) private subscriptionExists;
    bytes32[] private subscriptionKeys;

    // ─── Attack Vector Detector Registry ──────────────────────────────────
    mapping(uint256 => IAttackVectorDetector[]) private detectorsByTopic;
    mapping(bytes32 => bool) private registeredDetectors;
    bytes32[] private detectorIds;

    /// @notice Gas limit for callback execution on the destination chain
    uint64 private constant GAS_LIMIT = 1000000;

    // ─── Events emitted by this contract ──────────────────────────────────
    /**
     * @notice Fired every time a suspicious address is identified.
     *         Indexing `origin` and `suspiciousAddr` lets off-chain indexers
     *         quickly query the history.
     */
    event ThreatDetected(
        uint256 indexed originChainId,
        address indexed suspiciousAddr,
        bytes32 indexed detectorId,
        bytes32 originTxHash
    );

    event DetectorRegistered(
        bytes32 indexed detectorId,
        address indexed detectorAddress,
        uint256 indexed topic
    );

    event DetectorUnregistered(
        bytes32 indexed detectorId,
        address indexed detectorAddress
    );

    // ─── Constructor ──────────────────────────────────────────────────────
    /**
     * @param _callback_  Address of the destination-chain SuspiciousAddressRegistry.
     * @param _destinationChainId_  Chain id where the registry is deployed.
     */
    constructor(address _callback_, uint256 _destinationChainId_) payable {
        callbackContract = _callback_;
        destinationChainId = _destinationChainId_;
    }

    /**
     * @notice Generates a unique key for a subscription based on its parameters
     * @dev Uses keccak256 hash of the encoded parameters to create a deterministic key
     * @param chain_id The chain ID of the subscription
     * @param contract_address The contract address being monitored
     * @param topic_0 The event signature hash (topic 0)
     * @param topic_1 The first indexed parameter filter
     * @param topic_2 The second indexed parameter filter
     * @param topic_3 The third indexed parameter filter
     * @return A unique bytes32 key identifying the subscription
     */
    function _subscriptionKey(
        uint256 chain_id,
        address contract_address,
        uint256 topic_0,
        uint256 topic_1,
        uint256 topic_2,
        uint256 topic_3
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    chain_id,
                    contract_address,
                    topic_0,
                    topic_1,
                    topic_2,
                    topic_3
                )
            );
    }

    // ─── react() — main entry point called by ReactVM ─────────────────────
    /**
     * @notice Main entry point called by ReactVM for each matching log
     * @dev Delegates detection to registered attack vector detectors based on topic_0
     * @param log The log record to analyze
     */
    function react(LogRecord calldata log) external override vmOnly {
        uint256 topic0 = log.topic_0;
        
        IAttackVectorDetector[] memory detectors = detectorsByTopic[topic0];
        
        for (uint256 i = 0; i < detectors.length; i++) {
            IAttackVectorDetector detector = detectors[i];
            
            if (!detector.isActive()) {
                continue;
            }
            
            (bool detected, address suspiciousAddress, bytes memory payload) = detector.detect(log);
            
            if (detected) {
                emit ThreatDetected(
                    log.chain_id,
                    suspiciousAddress,
                    detector.getDetectorId(),
                    bytes32(0)
                );
                
                emit Callback(
                    destinationChainId,
                    callbackContract,
                    GAS_LIMIT,
                    payload
                );

                // If atleast one of the event is captured, lets stop the execution
                break;
            }
        }
    }

    // ─── Attack Vector Detector Management ────────────────────────────────
    /**
     * @notice Registers a new attack vector detector
     * @dev Only callable by the contract owner
     * @param detectorAddress The address of the detector contract
     */
    function registerDetector(address detectorAddress) external onlyOwner {
        if (detectorAddress == address(0)) revert InvalidDetectorAddress();
        
        IAttackVectorDetector detector = IAttackVectorDetector(detectorAddress);
        bytes32 detectorId = detector.getDetectorId();
        
        if (registeredDetectors[detectorId]) revert DetectorAlreadyRegistered();
        
        uint256 topic = detector.getMonitoredTopic();
        detectorsByTopic[topic].push(detector);
        registeredDetectors[detectorId] = true;
        detectorIds.push(detectorId);
        
        emit DetectorRegistered(detectorId, detectorAddress, topic);
    }

    /**
     * @notice Unregisters an attack vector detector
     * @dev Only callable by the contract owner
     * @param detectorAddress The address of the detector contract to remove
     */
    function unregisterDetector(address detectorAddress) external onlyOwner {
        if (detectorAddress == address(0)) revert InvalidDetectorAddress();
        
        IAttackVectorDetector detector = IAttackVectorDetector(detectorAddress);
        bytes32 detectorId = detector.getDetectorId();
        
        if (!registeredDetectors[detectorId]) revert DetectorNotFound();
        
        uint256 topic = detector.getMonitoredTopic();
        IAttackVectorDetector[] storage detectors = detectorsByTopic[topic];
        
        for (uint256 i = 0; i < detectors.length; i++) {
            if (address(detectors[i]) == detectorAddress) {
                detectors[i] = detectors[detectors.length - 1];
                detectors.pop();
                break;
            }
        }
        
        registeredDetectors[detectorId] = false;
        
        emit DetectorUnregistered(detectorId, detectorAddress);
    }

    // ─── Setters ─────────────────────────────────────────────────────────
    /**
     * @notice Updates the callback contract address on the destination chain
     * @dev Only callable by the contract owner
     * @param _callback The new callback contract address
     */
    function setCallback(address _callback) external onlyOwner {
        callbackContract = _callback;
    }

    /**
     * @notice Updates the destination chain ID for callbacks
     * @dev Only callable by the contract owner
     * @param _destinationChainId The new destination chain ID
     */
    function setDestinationChainId(
        uint256 _destinationChainId
    ) external onlyOwner {
        destinationChainId = _destinationChainId;
    }

    // ─── Subscription management ─────────────────────────────────────────
    /**
     * @notice Dynamically subscribes to events from a contract on a specified chain
     * @dev Allows the contract owner to add new event subscriptions at runtime.
     * Restricted to Reactive Network calls only.
     * @param chain_id The chain ID where the contract to monitor is deployed
     * @param contract_address The address of the contract to monitor
     * @param subscriber The address to filter events by (used in topic_1)
     * @param topic_0 The event signature hash to subscribe to
     */
    function subscribe(
        uint256 chain_id,
        address contract_address,
        address subscriber,
        uint256 topic_0
    ) external rnOnly onlyOwner {
        service.subscribe(
            chain_id,
            contract_address,
            topic_0,
            REACTIVE_IGNORE,
            uint256(uint160(subscriber)),
            REACTIVE_IGNORE
        );
        bytes32 key = _subscriptionKey(
            chain_id,
            contract_address,
            topic_0,
            REACTIVE_IGNORE,
            uint256(uint160(subscriber)),
            REACTIVE_IGNORE
        );
        if (!subscriptionExists[key]) {
            subscriptionsByKey[key] = Subscription(
                chain_id,
                contract_address,
                topic_0,
                REACTIVE_IGNORE,
                uint256(uint160(subscriber)),
                REACTIVE_IGNORE
            );
            subscriptionExists[key] = true;
            subscriptionKeys.push(key);
        }
        subscriptionStatus[key] = true;
    }

    /**
     * @notice Dynamically unsubscribes from events for a specific contract and event type
     * @dev Allows the contract owner to remove event subscriptions at runtime.
     * Restricted to Reactive Network calls only.
     * @param chain_id The chain ID of the monitored contract
     * @param contract_address The address of the monitored contract
     * @param subscriber The subscriber address used in the subscription
     * @param topic_0 The event signature hash to unsubscribe from
     */
    function unsubscribe(
        uint256 chain_id,
        address contract_address,
        address subscriber,
        uint256 topic_0
    ) external rnOnly onlyOwner {
        service.unsubscribe(
            chain_id,
            contract_address,
            topic_0,
            REACTIVE_IGNORE,
            uint256(uint160(subscriber)),
            REACTIVE_IGNORE
        );
        bytes32 key = _subscriptionKey(
            chain_id,
            contract_address,
            topic_0,
            REACTIVE_IGNORE,
            uint256(uint160(subscriber)),
            REACTIVE_IGNORE
        );
        subscriptionStatus[key] = false;
    }

    // ─── Getters ─────────────────────────────────────────────────────────
    /**
     * @notice Returns the current callback contract address
     * @dev This is the address on the destination chain that receives threat notifications
     * @return The address of the callback contract
     */
    function getCallback() external view returns (address) {
        return callbackContract;
    }

    /**
     * @notice Returns all registered detectors for a specific topic
     * @param topic The topic_0 hash to query
     * @return Array of detector addresses
     */
    function getDetectorsByTopic(uint256 topic) external view returns (IAttackVectorDetector[] memory) {
        return detectorsByTopic[topic];
    }

    /**
     * @notice Checks if a detector is registered
     * @param detectorId The detector ID to check
     * @return True if the detector is registered
     */
    function isDetectorRegistered(bytes32 detectorId) external view returns (bool) {
        return registeredDetectors[detectorId];
    }

    /**
     * @notice Returns all registered detector IDs
     * @return Array of detector IDs
     */
    function getAllDetectorIds() external view returns (bytes32[] memory) {
        return detectorIds;
    }

    /**
     * @notice Return the subscriptions that are currently active and are pausable.
     * @dev Required override from AbstractPausableReactive. Used for pausing/resuming
     * @return An array of Subscription structs representing all pausable subscriptions
     */
    function getPausableSubscriptions()
        internal
        view
        override
        returns (Subscription[] memory)
    {
        uint256 activeCount = 0;
        for (uint256 i = 0; i < subscriptionKeys.length; i++) {
            if (subscriptionStatus[subscriptionKeys[i]]) {
                activeCount++;
            }
        }

        Subscription[] memory result = new Subscription[](activeCount);
        uint256 index = 0;
        for (uint256 i = 0; i < subscriptionKeys.length; i++) {
            bytes32 key = subscriptionKeys[i];
            if (subscriptionStatus[key]) {
                result[index] = subscriptionsByKey[key];
                index++;
            }
        }
        return result;
    }
}
